@model IntegrationForm
@*
    CRM Form    
    Based on the following third-parties:
        - Bootstrap Validator: http://1000hz.github.io/bootstrap-validator/
        - Date picker: http://eonasdan.github.io/bootstrap-datetimepicker
        - Moments dates: http://momentjs.com/docs/
*@

<style type="text/css">
	.form-title:before {
		
		border: 1px solid #fff !important;
	}
</style>
<div class="modal fade and carousel slide position-fixed" id="lightbox">
	<div class="modal-dialog modal-dialog-centered modal-lg">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-label="Close">
				  <span aria-hidden="true">&times;</span>
				</button>
			</div>
			<div class="modal-body">
			<section id="request-info" class="mx-auto bg-white py-3 text-black" @Html.DxaEntityMarkup()>
				  <div class="container-fluid">
					 <h6 class="text-center py-4 my-2 text-uppercase offerings-title form-title position-relative"
					 @Html.DxaPropertyMarkup(() => Model.Title)>@Model.Title</h6>
					<div class="text-center pb-3 my-2 sub-heading" @Html.DxaPropertyMarkup(() => Model.Content)>
						@Model.Content
					</div>
					<div class="row"><div class="col-md-5 mx-auto">
					<form method="post" autocomplete="off" data-toggle="validator" action="@(WebRequestContext.Localization.Path + Model.PostUrl)">
				
						@if (Model.Fields == null || !Model.Fields.Any())
						{
							@* Display an empty field container when no fields are defined *@
							<div class="form-group" style="border-radius: 4px; padding-left: 10px;" @Html.DxaPropertyMarkup(() => Model.Fields, 0)>
								<label style="color: lightgrey;">[Field]</label>
								<input class="form-control" style="border-style: dashed; border-color: lightgrey; border-width: 2px;pointer-events: none;" tabindex="-1">
							</div>
						}
						else
						{
							if (!WebRequestContext.IsPreview)
							{
								@* If we put in an Anti Forgery Token, the Page can't be edited in XPM anymore *@
								// TODO: Remove this using Javascript instead so it is only removed when inside XPM
								@Html.AntiForgeryToken()
							}

							int i = 0;
							foreach (var field in Model.Fields)
							{
								if (field.IsReadOnly && Model.FormType.Equals("Create", StringComparison.OrdinalIgnoreCase) ||
									field.InvalidFieldDefinition == true)
								{
									continue;
								}
								<div class="form-group @(field.AggregatedFieldValidation.IsRequired ? "required" : "")" style="border-radius: 4px; padding-left: 10px;" @Html.DxaPropertyMarkup(() => Model.Fields, i++)>
								   <label class="control-label pl-0" for="@field.ExternalField.FieldName" @Html.DxaPropertyMarkup(() => field.Label)>@field.Label</label>
									 <div 
										@if (field.AggregatedFieldValidation.Type.Equals("date"))
										{
											@: class="input-group datepicker" 
											if (field.AggregatedFieldValidation.Format != null)
											{
												@: data-date-format="@field.AggregatedFieldValidation.Format" 
											}
										} @Html.DxaPropertyMarkup(() => field.ExternalField)>                    
									 
										@if (field.ExternalField != null)
										{
											<input 
												@if (field.AggregatedFieldValidation.Type != null)
												{
													if (field.AggregatedFieldValidation.Type.Equals("date"))
													{
														@: data-date-selector="true"
													}
													else
													{
														@: type="@field.AggregatedFieldValidation.Type"
													}
												}
												@if (field.AggregatedFieldValidation.IsRequired)
												{
													@: required
												}
												@if (field.AggregatedFieldValidation.Pattern != null)
												{
													@: pattern="@field.AggregatedFieldValidation.Pattern"
												}
												@if (field.AggregatedFieldValidation.MinLength != null)
												{
													@: minlength="@field.AggregatedFieldValidation.MinLength"
												}
												@if (field.AggregatedFieldValidation.MaxLength != null)
												{
													@: maxlength="@field.AggregatedFieldValidation.MaxLength"
												}
												@if (field.AggregatedFieldValidation.ErrorMessage != null)
												{
													@: data-error="@field.AggregatedFieldValidation.ErrorMessage"
												}
												@if (field.AggregatedFieldValidation.AjaxValidator != null)
												{
													@: data-remote="@field.AggregatedFieldValidation.AjaxValidator"
												}
											
												name="@field.ExternalField.FieldName"
												id="@field.ExternalField.FieldName"
												class="form-control"
												@if (field.Value != null)
												{
													@:value="@field.Value"
												}
												@if (field.IsReadOnly)
												{
													@:disabled="disabled"
												}
											/>
											if (field.AggregatedFieldValidation.Type.Equals("date") )
											{
												<span class="input-group-addon">
													<span class="glyphicon glyphicon-calendar"></span>
												</span>
											}
											<div class="help-block with-errors"></div>
										}
										else
										{
											<input style="border-style: dashed; border-color: lightgrey; border-width: 2px;">
										}
										
									
									 </div>
								</div>
							}

							if (Model.StaticFields != null)
							{
								foreach (var staticField in Model.StaticFields)
								{
									<input type="hidden" name="@staticField.ExternalField.FieldName" value="@staticField.FieldValue">
								}
							}
							if (Model.AdditionalFields != null)
							{
								foreach (var addField in Model.AdditionalFields)
								{
									<input type="hidden" name="____@addField.ResolveFieldName()" value="@addField.ResolveFieldValue()">
								}
							}
							<input type="hidden" name="___formId" value="@Model.Id">
							if (Model.SuccessUrl != null)
							{
								<input type="hidden" name="___successUrl" value="@Model.SuccessUrl.Url">
							}
							if (Model.ErrorUrl != null)
							{
								<input type="hidden" name="___errorUrl" value="@Model.ErrorUrl.Url">
							}

						}
						@if (Model.PrivacyStatement !=  null)
						{
							<div class="form-group" style="font-style: italic; padding-left: 10px;" @Html.DxaPropertyMarkup(()=> Model.PrivacyStatement)>
								@Html.DxaRichText(Model.PrivacyStatement)
							</div>
						}
						@if (Model.RequiredTickboxLabel != null)
						{
							<div class="form-group required" style="border-radius: 4px; padding-left: 10px;">
								<div class="checkbox">
									<label class="control-label" @Html.DxaPropertyMarkup(()=> Model.RequiredTickboxLabel)>
										<input type="checkbox" id="__requiredTickbox" data-error="@Model.RequiredTickboxErrorMessage" required>
										@Model.RequiredTickboxLabel
									</label>
									<div class="help-block with-errors"></div>
								</div>
							</div>
						}

						<div class="form-group">
							<button type="submit" class="btn btn-secondary px-4 py-2 my-4 crm-form-submit-button" style="margin-left: 40%;">@Model.SubmitLabel</button>
							@* Generate a link version of the button that works better with XPM (only on staging sites) *@

							@if (WebRequestContext.IsPreview)
							{
								<a class="btn btn-secondary px-4 py-2 my-4" style="margin-left: 40%; display: none;" @Html.DxaPropertyMarkup(()=> Model.SubmitLabel)>@Model.SubmitLabel</a>
							}            
						</div>
						@if (Model.ErrorMessage != null)
						{
							<div class="alert alert-danger">@Model.ErrorMessage</div>
						}
						else if (Model.SuccessMessage != null)
						{
							<div class="alert alert-success">@Model.SuccessMessage</div>
						}

					</form>
					</div></div>
				  </div>
				</section>
			</div>
			</div>
		</div>
	</div>
